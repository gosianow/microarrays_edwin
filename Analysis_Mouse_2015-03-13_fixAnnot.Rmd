---
title: "DE analysis for Edwin"
author: "Gosia Nowicka"
date: "25 Feb 2015"
output: html_document
---

# Data and experiment description

Affymetrix Mouse Gene 2.0 ST arrays

# Prepare data

```{r setup, echo = FALSE}
opts_knit$set(root.dir = "/home/Shared/data/array/Microarray_Edwin")
opts_chunk$set(message=FALSE, warning = FALSE, cache = TRUE, size="small", tidy=TRUE, tidy.opts=list(blank=FALSE, width.cutoff=70), dev = "pdf")
options(width=100)
```

Load targets table with information about samples.

```{r}
targets <- read.table(file.path("metadata", "targets.xls"), header = TRUE, sep = "\t", comment.char = "", as.is = TRUE)

targets

```

Load Affy CEL data using `oligo` package. Plot the distributions of raw probe expression in all samples.

```{r}
library(oligo)
library(pd.mogene.2.0.st)

ff <- as.character(targets$FileName)

x <- oligo::read.celfiles(filenames = ff)

par(mar = c(12, 4, 4, 2) + 0.1) # c(bottom, left, top, right), default = c(5, 4, 4, 2) + 0.1
boxplot(x, las = 2, col = targets$colors, names = targets$labels, las=2)

par(mar = c(5, 4, 4, 2) + 0.1)
hist(x, col = targets$colors, lwd = 2)
legend("topright", legend = targets$labels, col =  targets$colors, lty = 1, lwd = 2, cex = 0.8)

```

# Normalize data with probe-level model

Run `fitProbeLevelModel` and create NUSE and RLE plots (https://genevestigator.com/userdocs/manual/qc.html).

```{r}
fitplm <- oligo::fitProbeLevelModel(x)

par(mar = c(12, 4, 4, 2) + 0.1) # c(bottom, left, top, right), default = c(5, 4, 4, 2) + 0.1
oligo::NUSE(fitplm, col = targets$colors, names = targets$labels, las=2)

par(mar = c(12, 4, 4, 2) + 0.1) # c(bottom, left, top, right), default = c(5, 4, 4, 2) + 0.1
oligo::RLE(fitplm, col = targets$colors, names = targets$labels, las=2)

```

# Normalize data with RMA method

```{r}
eset <- oligo::rma(x) ## Is the expression in log2 scale?

par(mar = c(12, 4, 4, 2) + 0.1) # c(bottom, left, top, right), default = c(5, 4, 4, 2) + 0.1
boxplot(eset, las = 2, col = targets$colors, names = targets$labels)

par(mar = c(5, 4, 4, 2) + 0.1)
hist(eset, col = targets$colors, lwd = 2)
legend("topright", legend = targets$labels, col =  targets$colors, lty = 1, lwd = 2, cex = 0.8)

library(limma)
labels <- paste0(ifelse(is.na(targets$ctrlRep), "", paste0(targets$ctrlRep, " ")), targets$labels)

### plot MDS for all samples
mds.dendo <- mds <- plotMDS(eset, top=1000, col = targets$colors, labels = labels, cex = 1.2)
### plot only points
plot(mds$x, mds$y, pch = 16, cex = 1.5, col = targets$colors)

### zoom in
mds <- plotMDS(eset, top=1000, col = targets$colors, labels = labels, cex = 1.2, xlim = c(-1.5, 1.5), ylim = c(-1, 1))

### plot MDS for all samples except HeLa and whole bone marrow controls 
ex <- !targets$labels %in% c("control_wholeBoneMarrow", "control_HeLa")
mds <- plotMDS(eset[, ex], top=1000, col = targets$colors[ex], labels = labels[ex], cex = 1)

### plot only points
plot(mds$x, mds$y, pch = 16, cex = 1.5, col = targets$colors[ex] )


library(ggplot2)
library(ggdendro)

d <- mds.dendo$distance.matrix
rownames(d) <- labels
hc <- hclust(as.dist(d), method = "complete")
ggdendrogram(hc, theme_dendro = TRUE) + theme(axis.text.x = element_text(colour = targets$colors[hc$order], size = 13)) 

```

# Get NetAffx annotation of probesets

```{r}
####### NetAffx Annotation with getNetAffx()

infoNetAffx <- pData(getNetAffx(eset, "transcript"))
colnames(infoNetAffx)

```



# Filtering

Keep only the main probes.


```{r}
table(infoNetAffx$category, useNA = "always")

keepMAIN <- infoNetAffx$category == "main"

eset.main <- eset[keepMAIN, ]

```



Keep only the probes that come from chr 1-19, X and Y.

```{r}
keepCHR <- featureNames(eset.main) %in% rownames(infoNetAffx)[which(infoNetAffx$seqname %in% paste0("chr", c(1:19, "Y", "X")), useNames = TRUE)]

table(keepCHR)

eset.main <- eset.main[keepCHR, ]

```


# Get annotation from formated files from Affy website

http://www.affymetrix.com/analysis/index.affx

```{r}
library(limma)

### files that are formated for easy load 
annof <- list.files("NetAffx", pattern = ".tsv", full.names = TRUE)
annof

### use gene_list

allLines <- readLines(annof[2], n=-1)

gl <- data.frame(strsplit2(allLines, "\t"), stringsAsFactors = FALSE)
colnames(gl) <- gsub(pattern = " ", replacement = "" ,gl[1,])
gl <- gl[-1,]
rownames(gl) <- gl$TranscriptClusterID

colnames(gl)

annot <- gl[ featureNames(eset.main) ,c("GeneSymbol", "EntrezGeneID", "GeneTitle")]


```

# Get ENSEMBL annotation using biomaRt

```{r}

library(biomaRt)

mart <- useMart("ensembl")

mart <- useMart("ensembl", dataset="mmusculus_gene_ensembl")

attr <- listAttributes(mart)

attr[grep("affy", attr$name),]

genes <- getBM(attributes = c("ensembl_gene_id","external_gene_name", "description","affy_mogene_2_1_st_v1"), filters="affy_mogene_2_1_st_v1", values=featureNames(eset.main), mart=mart)

### clean the description
genes$description <- strsplit2(genes$description, " \\[Source")[, 1]

### Merge the info about multiple genes into one string
library(plyr)

genes.m <- ddply(genes, "affy_mogene_2_1_st_v1", summarize, GeneSymbol_Ensembl = paste0(external_gene_name, collapse = " /// "), GeneTitle_Ensembl = paste0(description, collapse = " /// "), EnsemblGeneID = paste0(ensembl_gene_id, collapse = " /// "))

annot.m <- merge(annot, genes.m, by.x = 0, by.y = "affy_mogene_2_1_st_v1", all.x = TRUE, sort = FALSE)
colnames(annot.m)[1] <- "ProbesetID"
rownames(annot.m) <- annot.m[,"ProbesetID"]

annot.m[is.na(annot.m)] <- "---"

fData(eset.main) <- annot.m[featureNames(eset.main), ]

```


# Filtering probe sets with low expression 

Filter probesets with low expression. For that use the background information from antigenomic probesets and GC content.

```{r}
### Get probe 2 transcript match
probeInfo <- oligo::getProbeInfo(x, field = c('fid', 'fsetid', 'level', 'type', 'transcript_cluster_id'), probeType = "pm", target='core')

pmSeq <- oligo::pmSequence(x, target='core')

### Get GC content per probe
library(Biostrings)
gcCont <- letterFrequency(pmSeq, letters='CG')[,1]

probeInfo$gcCont <- gcCont

### Get the background expression levels for different GC ammount
antigm <- infoNetAffx[infoNetAffx$category == "control->bgp->antigenomic", "probesetid"]

bgExpr <- exprs(eset)[as.character(antigm), targets$labels != "control_HeLa"]

bgProbeInfo <- subset(probeInfo, probeInfo$type == "control->bgp->antigenomic")

### see how many probes are for each GC content
table(bgProbeInfo$gcCont)


library(plyr)
library(ggplot2)
library(reshape2)

bgTransInfo <- ddply(bgProbeInfo, "transcript_cluster_id", summarize,  gcCont=mean(gcCont))

expr <- exprs(eset.main)[,targets$labels != "control_HeLa"]

### Get the GC content for all the probe sets
transInfo <- ddply(probeInfo, "transcript_cluster_id", summarize,  gcCont=mean(gcCont))
rownames(transInfo) <- transInfo$transcript_cluster_id
transInfo <- transInfo[rownames(expr), ]
transInfo$gcCont <- round(transInfo$gcCont)

table(transInfo$gcCont)

### plot expression for background and main probes across different GC content
bgdf <- data.frame(bgTransInfo, bgExpr)

bgdf.m <- melt(bgdf, id.vars = c("transcript_cluster_id", "gcCont"), variable.name = "Samples", value.name = "Expression")

df <- data.frame(transInfo, expr)

df.m <- melt(df, id.vars = c("transcript_cluster_id", "gcCont"), variable.name = "Samples", value.name = "Expression")

df.m$Type <- "Main"
bgdf.m$Type <- "BGP"

df.all <- rbind(df.m, bgdf.m)
df.all$gcCont <- factor(df.all$gcCont, levels = 3:25)

ggp <- ggplot(data = df.all, aes(x = gcCont, y = Expression, fill = Type)) +
  geom_boxplot() +
  theme_bw() +
  theme(legend.position="top")

print(ggp)


### Use median expression as cutoff 
library(matrixStats)

bgTransInfo$MedianExpr <- rowMedians(bgExpr)
bgTransInfo$Q075Expr <- rowQuantiles(bgExpr, probs = 0.75)
bgTransInfo

transInfo$minExpr <- factor(transInfo$gcCont, levels = bgTransInfo$gcCont)
levels(transInfo$minExpr) <- bgTransInfo$MedianExpr
# levels(transInfo$minExpr) <- bgTransInfo$Q075Expr
transInfo$minExpr <- as.numeric(as.character(transInfo$minExpr))

keepEXPR <- sapply(1:nrow(expr), function(tr){ sum(expr[tr, ] > transInfo$minExpr[tr]) >= ncol(expr) } )

table(keepEXPR)

eset.main <- eset.main[keepEXPR, ]

eset.main

```





## Comparison 1

Compare leukemia samples versus 3 different controls: CD4+, CD4+CD8+ and CD8+.

```{r}
### sort samples by groups
ord <- order(targets$groups)
targets <- targets[ord, ]
eset.main <- eset.main[ ,ord]


### keep only leukemia and control CD4+, CD4+CD8+ and CD8+ samples
samples2keep <- grepl("leukemia|control_CD", targets$labels)

treatments <- data.frame(Treatment = as.character(targets$groups[samples2keep]))
treatments

eset <- eset.main[,samples2keep] 

design <- model.matrix(~ 0 + Treatment, data=treatments)
rownames(design) <- targets$labels[samples2keep]
design


fit <- lmFit(eset, design)

contrasts <- cbind(CtrlCD4 = c(-1, 0, 0, 1), CtrlCD4CD8 = c(0, -1, 0, 1), CtrlCD8 = c(0, 0, -1, 1))
contrasts


fit2 <- contrasts.fit(fit, contrasts)

fit2 <- eBayes(fit2, trend = TRUE)

plotSA(fit2)

results <- decideTests(fit2, method="separate", adjust.method="BH", p.value=0.05, lfc=0)
summary(results)

## with the FC cutoff
results <- decideTests(fit2, method="separate", adjust.method="BH", p.value=0.05, lfc=1)
summary(results)

write.fit(fit2, results = results, file = "results.xls", adjust = "BH")

vennDiagram(results,include=c("up", "down"))

```



```{r}

limma::plotMA(fit2, coef = "CtrlCD4", status = results[, "CtrlCD4"], values = c(-1, 0, 1), col = c("red", "black", "green"), cex = c(0.7, 0.3, 0.7), main = "CtrlCD4")
abline(0,0,col="blue")
limma::plotMA(fit2, coef = "CtrlCD4CD8", status = results[, "CtrlCD4CD8"], values = c(-1, 0, 1), col = c("red", "black", "green"), cex = c(0.7, 0.3, 0.7), main = "CtrlCD4CD8")
abline(0,0,col="blue")
limma::plotMA(fit2, coef = "CtrlCD8", status = results[, "CtrlCD8"], values = c(-1, 0, 1), col = c("red", "black", "green"), cex = c(0.7, 0.3, 0.7), main = "CtrlCD8")
abline(0,0,col="blue")


library(ggplot2)

coefs <- c("CtrlCD4", "CtrlCD4CD8", "CtrlCD8")

for(i in 1:length(coefs)){
  
  coef <- coefs[i]

  table <- topTable(fit2, coef=coef, n=Inf)
  table$threshold = as.factor(table$adj.P.Val < 0.05 & abs(table$logFC) > 1)
  gg1 <- ggplot(data=table, aes(x=logFC, y=-log10(P.Value), colour=threshold)) +
    geom_point(alpha=0.4, size=1.75) + theme_bw() +ggtitle(coef) +
    theme(legend.position = "none") +
    xlab("log2 fold change") + ylab("-log10 p-value")
  
  print(gg1)
  hist(table$P.Value, breaks = 100, main = coef, xlab = "P-values")
  
}


```

Plot expression of top significant genes/probe sets.

```{r, fig.width = 11, fig.height = 11}
library(ggplot2)
library(reshape2)

topn <- 20
exp <- exprs(eset)

for(i in 1:length(coefs)){
  # i = 1
  coef <- coefs[i]
  
  tt <- topTable(fit2, coef=coef, n=Inf, p.value=0.05, lfc=1)
  write.table(tt, paste0("topTable_",coef,".xls"), quote = FALSE, sep = "\t", row.names = FALSE)
  
  print(coef)
  print(head(tt[, c("GeneSymbol", "logFC", "AveExpr", "t", "P.Value", "adj.P.Val", "B")], topn))
  
  topp <- rownames(tt)[1:topn]
  
  df <- data.frame(Gene = topp, exp[topp,])
  df.m <- reshape2::melt(df, id.vars = "Gene", value.name = "Expression", variable.name = "Sample")
  ### keep order of genes as in tt
  df.m$Gene <- factor(df.m$Gene, levels = topp)
  ### add Gene Symbol to the facet labels
  lab.fct <- paste0(topp, "\n", strsplit2(tt[topp, "GeneSymbol"], " /// ")[,1])
  levels(df.m$Gene) <- lab.fct
  
  ggp <- ggplot(df.m, aes(x = Sample, y = Expression)) +  
    theme_bw() +
    theme(axis.text.x = element_text(angle = 80, hjust = 1, size = 10), plot.title = element_text(size = 16), strip.text.x = element_text(size = 10)) +
    scale_x_discrete(labels=targets$groups[samples2keep]) +
    labs(title = coef, y = "Log2 expression") +
    geom_bar(stat = "identity", colour = targets$colors[samples2keep], fill = targets$colors[samples2keep]) +
    facet_wrap(~ Gene, scales="free_y", ncol=4) 
  
  print(ggp)    
  
}


```


# GO analysis

```{r}

library(topGO)
library(Rgraphviz)


affyLib <- "mogene20sttranscriptcluster.db"

coefs <- c("CtrlCD4", "CtrlCD4CD8", "CtrlCD8")
coef <- coefs[1]

tt <- topTable(fit2, coef=coef, n=Inf)
geneList <- rep(0, nrow(tt))
names(geneList) <- rownames(tt)
geneList[tt$adj.P.Val < 0.05 & abs(tt$logFC) > 1] <- 1
table(geneList)

### Function used to create new topGOdata object
fun.gene.sel <- function(geneList) {
  return(geneList <- ifelse(geneList==0, FALSE, TRUE))
}


allRes.Fisher.merged <- NULL
allRes.Fisher.elim.merged <- NULL


for(go in c("BP","MF","CC")){
  # go = "BP"
  
  sampleGOdata <- new("topGOdata", description = paste0("Simple session for ", coef), ontology = go, allGenes = geneList, geneSel = fun.gene.sel , nodeSize = 10, annot = annFUN.db, affyLib = affyLib)
  
  print(sampleGOdata)
  
  
  # Fisher's exact test which is based on gene counts, and a Kolmogorov-Smirnov like test which computes enrichment based on gene scores
  # For the method classic each GO category is tested independently
  
  resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher")
  resultFisher.elim <- runTest(sampleGOdata, algorithm = "elim", statistic = "fisher")
  
  
  pValues.Fisher <- score(resultFisher)
  topNodes.Fisher <- length(pValues.Fisher)
  
  pValues.Fisher.elim <- score(resultFisher.elim)
  topNodes.Fisher.elim <- length(pValues.Fisher.elim)
  
  
  allRes.Fisher <- GenTable(sampleGOdata, classicFisher = resultFisher, elimFisher = resultFisher.elim, orderBy = "classicFisher", ranksOf = "elimFisher", topNodes = topNodes.Fisher) 
  
  allRes.Fisher$GO <- go   
  allRes.Fisher.merged <- rbind(allRes.Fisher.merged, allRes.Fisher)
  
  
  allRes.Fisher.elim <- GenTable(sampleGOdata, classicFisher = resultFisher, elimFisher = resultFisher.elim, orderBy = "elimFisher", ranksOf = "classicFisher", topNodes = topNodes.Fisher.elim)      
  
  allRes.Fisher.elim$GO <- go 
  allRes.Fisher.elim.merged <- rbind(allRes.Fisher.elim.merged, allRes.Fisher.elim)
  
#   showSigOfNodes(sampleGOdata, score(resultFisher), firstSigNodes = 5, useInfo = 'all')
#   showSigOfNodes(sampleGOdata, score(resultFisher.elim), firstSigNodes = 5, useInfo = 'all')

  
}


allRes.Fisher.merged$classicFisher.adj <- p.adjust(allRes.Fisher.merged$classicFisher, method = "BH")
allRes.Fisher.merged <- allRes.Fisher.merged[order(allRes.Fisher.merged$classicFisher.adj, decreasing = FALSE), ]

head(allRes.Fisher.merged, 20)


write.table(allRes.Fisher.merged, paste("GO_Fisher_",coef,".xls", sep=""), sep="\t", row.names=F, quote = FALSE)


allRes.Fisher.elim.merged$elimFisher.adj <- p.adjust(allRes.Fisher.elim.merged$elimFisher, method = "BH")
allRes.Fisher.elim.merged <- allRes.Fisher.elim.merged[order(allRes.Fisher.elim.merged$elimFisher.adj, decreasing = FALSE), ]

head(allRes.Fisher.elim.merged, 20)

write.table(allRes.Fisher.elim.merged, paste("GO_Fisher_elim_",coef,".xls", sep=""), sep="\t", row.names=F)



```

In GO analysis should I merge and adjust the p-values from different go or keep it separetely?
Should I use classic Fisher or elim Fisher?


# Gene set enrichment analysis with C7  Immunologic genes sets

```{r}
# gene sets from MSigDB with ENTREZ IDs
load("MSigDB_v4_0/mouse_c7_v4.rdata")

mysets <- Mm.c7
length(mysets)

### Create an Index for camera
annot <- fData(eset.main)

EntrezGeneID <- strsplit2(annot$EntrezGeneID, " /// ")

nrow = nrow(EntrezGeneID)
ncol = ncol(EntrezGeneID)

Index <- lapply(mysets, function(ms){  
  eg <- matrix(EntrezGeneID %in% ms, nrow = nrow, ncol = ncol, byrow = FALSE)
  rowSums(eg) > 0 
  })

### sort samples by groups
ord <- order(targets$groups)
targets <- targets[ord, ]
eset.main <- eset.main[ ,ord]

### keep only leukemia and control CD4+, CD4+CD8+ and CD8+ samples
samples2keep <- grepl("leukemia|control_CD", targets$labels)

treatments <- data.frame(Treatment = as.character(targets$groups[samples2keep]))
treatments

eset <- eset.main[, samples2keep] 

design <- model.matrix(~ 0 + Treatment, data=treatments)
rownames(design) <- targets$labels[samples2keep]
design


contrasts <- cbind(CtrlCD4 = c(-1, 0, 0, 1), CtrlCD4CD8 = c(0, -1, 0, 1), CtrlCD8 = c(0, 0, -1, 1))
contrasts



gsea <- camera(y = eset, index=Index, design=design, contrast=contrasts[,"CtrlCD4"], trend.var=TRUE)

head(gsea)

table(gsea$FDR < 0.05)


gsea <- camera(y = eset, index=Index, design=design, contrast=contrasts[,"CtrlCD4CD8"], trend.var=TRUE)

head(gsea)

table(gsea$FDR < 0.05)



gsea <- camera(y = eset, index=Index, design=design, contrast=contrasts[,"CtrlCD8"], trend.var=TRUE)

head(gsea)

table(gsea$FDR < 0.05)



```









